betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_A <- lm(yA~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_A$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_A <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_A
## B:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_B <- lm(yB~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_B$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_B <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_B
### Simulated the common Z and G
set.seed(100,sample.kind = "Rounding")
N <- 1000
G <- sample(c(0,1,2),size = N, replace = T, prob = c(0.49,0.42,0.09))
Z <- rnorm(N,sd = 3)
### Simulate each population's disease status based on Z and G
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N,sd = 5)
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 5)
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_A <- lm(yA~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_A$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- (1/25)* as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_A <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_A
## B:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_B <- lm(yB~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_B$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- (1/25)* as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_B <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_B
### Simulated the common Z and G
set.seed(100,sample.kind = "Rounding")
N <- 1000
G <- sample(c(0,1,2),size = N, replace = T, prob = c(0.49,0.42,0.09))
Z <- rnorm(N,sd = 3)
### Simulate each population's disease status based on Z and G
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N,sd = 3)
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_A <- lm(yA~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_A$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- (1/9)* as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_A <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_A
## B:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_B <- lm(yB~Z + G)
#### Get the design matrix:
X <- cbind(rep(1,N),mod_B$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
I <- (1/9)* as.matrix(t(X)) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_B <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_B
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
yA <- beta0 + betaG*G + betaZ*Z + rlogis(N)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:1000) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:2000) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p2[i] <- summary(mod)$coefficient[3,4]
}
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p2 <- c()
for (i in 1:100) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p2[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p2 <- c()
for (i in 1:100) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p2[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
p1
p2
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:100) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p2 <- c()
for (i in 1:100) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p2[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
yA <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yA~Z+G)
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p2 <- c()
for (i in 1:800) {
yB <- beta0 + betaG*G + betaZ*Z + rnorm(N, sd = 3)
mod <- lm(yB~Z+G)
p2[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
### Simulated the common Z and G
set.seed(100,sample.kind = "Rounding")
N <- 1000
G <- sample(c(0,1,2),size = N, replace = T, prob = c(0.49,0.42,0.09))
Z <- rnorm(N,sd = 3)
### Simulate each population's disease status based on Z and G
## Eur:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
ylat_Eur <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_Eur <- ifelse(ylat_Eur >=0, 1, 0)
## Asia:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
ylat_As <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_As <- ifelse(ylat_As >=0, 1, 0)
### Case control counts across populations:
t <- rbind(table(y_Eur),table(y_As)) %>% as_tibble()
rownames(t) <- c("Euro","Asia")
kableExtra::kable(t, caption = "Case Control Counts across populations") %>%
kable_styling(latex_options = "HOLD_position", font_size = 10)
### Case control ratio across genotypes:
t <- cbind(c(y_Eur,y_As),c(G,G)) %>% as_tibble()
colnames(t) <- c("Y","G")
t <- t %>% group_by(G) %>% summarise(ratio = sum(Y)/n())
kableExtra::kable(t, caption = "Case Control Ratio across genotypes") %>%
kable_styling(latex_options = "HOLD_position", font_size = 10)
### Simulated the common Z and G
set.seed(100,sample.kind = "Rounding")
N <- 1000
G <- sample(c(0,1,2),size = N, replace = T, prob = c(0.49,0.42,0.09))
Z <- rnorm(N,sd = 3)
### Simulate each population's disease status based on Z and G
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
ylat_A <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_A <- ifelse(ylat_A >=0, 1, 0)
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
ylat_B <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_B <- ifelse(ylat_B >=0, 1, 0)
### Case control counts across traits:
t <- rbind(table(y_A),table(y_B)) %>% as_tibble()
rownames(t) <- c("A","B")
kableExtra::kable(t, caption = "Case Control Counts across traits") %>%
kable_styling(latex_options = "HOLD_position", font_size = 10)
### Case control ratio across genotypes:
t <- cbind(c(y_A,y_B),c(G,G)) %>% as_tibble()
colnames(t) <- c("Y","G")
t <- t %>% group_by(G) %>% summarise(ratio = sum(Y)/n())
kableExtra::kable(t, caption = "Case Control Ratio across genotypes") %>%
kable_styling(latex_options = "HOLD_position", font_size = 10)
## A:
mod_A <- glm(y_A~Z + G, family = binomial(link = "logit"))
summary(mod_A)$coefficients[3,4]
## B:
mod_B <- glm(y_B~ Z + G, family = binomial(link = "logit"))
summary(mod_B)$coefficients[3,4]
## A:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
### Theoretical Power
mod_A <- glm(y_A~Z + G, family = binomial(link = "logit"))
#### Get the design matrix:
X <- cbind(rep(1,N),mod_A$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
#beta <- as.numeric(mod_A$coefficients)
w <- c()
for (i in 1:N) {
si <- as.numeric(as.numeric(X[i,]) %*% beta)
w[i] <- dlogis(si)
}
I <- as.matrix(t(X)) %*% diag(w,nrow = N,ncol = N) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_A <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_A
## B:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
### Theoretical Power
mod_B <- glm(y_B~ Z + G, family = binomial(link = "logit"))
#### Get the design matrix:
X <- cbind(rep(1,N),mod_B$model[,-1])
### Compute the weight matrix W:
beta <- c(beta0,betaZ,betaG)
#beta <- as.numeric(mod_B$coefficients)
w <- c()
for (i in 1:N) {
si <- as.numeric(as.numeric(X[i,]) %*% beta)
w[i] <- dlogis(si)
}
I <- as.matrix(t(X)) %*% diag(w,nrow = N,ncol = N) %*% as.matrix(X)
#### Invert to get the true covariance matrix
V <- solve(I)
### Compute the power function:
delta <- sqrt(1/V[3,3])*(0-beta[3])
alpha <- 0.05
Power_AS <- 1- pnorm(delta - qnorm(alpha/2)) + pnorm(delta + qnorm(alpha/2))
Power_AS
set.seed(100,sample.kind = "Rounding")
## Euro:
beta0 <- -0.5
betaZ <- 0.8
betaG <- 0.3
p1 <- c()
for (i in 1:800) {
ylat_A <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_A_rep <- ifelse(ylat_A >=0, 1, 0)
mod <- glm(y_A_rep~Z+G, family = binomial(link = "logit"))
p1[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p1 <= alpha)
emp_power
set.seed(100,sample.kind = "Rounding")
## Asia:
beta0 <- -0.5
betaZ <- 0.1
betaG <- 0.3
p2 <- c()
for (i in 1:800) {
ylat_B <- beta0 + betaG*G + betaZ*Z + rlogis(N)
y_B_rep <- ifelse(ylat_B >=0, 1, 0)
mod <- glm(y_B_rep~Z+G, family = binomial(link = "logit"))
p2[i] <- summary(mod)$coefficient[3,4]
}
emp_power <- mean(p2 <= alpha)
emp_power
### Comparison:
pcomp <- tibble(P = c(p1,p2), trait = c(rep("A",800),rep("B",800)))
pcomp %>% ggplot(aes(x = P, fill = trait)) + geom_histogram(bins = 20, alpha=0.5, position="identity")
